
## Shell特殊变量：Shell $0, $#, $*, $@, $?, $和命令行参数



| 变量 | 含义                                                         |
| ---- | ------------------------------------------------------------ |
| $0   | 当前脚本的文件名                                             |
| $n   | 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 |
| $#   | 传递给脚本或函数的参数个数。                                 |
| $*   | 传递给脚本或函数的所有参数。                                 |
| $@   | 传递给脚本或函数的所有参数。被双引号(" ")包含时，与 $* 稍有不同，下面将会讲到。 |
| $?   | 上个命令的退出状态，或函数的返回值。                         |
| $$   | 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 |

## 命令行参数

运行脚本时传递给脚本的参数称为命令行参数。命令行参数用 $n 表示，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。

请看下面的脚本：

```
#!/bin/bash
echo "File Name: $0"
echo "First Parameter : $1"
echo "First Parameter : $2"
echo "Quoted Values: $@"
echo "Quoted Values: $*"
echo "Total Number of Parameters : $#"
```



 

运行结果：



```
$ sh test01.sh double moons
File Name: test01.sh
First Parameter : double
First Parameter : moons
Quoted Values: double moons
Quoted Values: double moons
Total Number of Parameters : 2

```



 

## $* 和 $@ 的区别

$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(" ")包含时，都以"$1" "$2" … "$n" 的形式输出所有参数。

但是当它们被双引号(" ")包含时，"$*" 会将所有的参数作为一个整体，以"$1 $2 … $n"的形式输出所有参数；"$@" 会将各个参数分开，以"$1" "$2" … "$n" 的形式输出所有参数。

下面的例子可以清楚的看到 $* 和 $@ 的区别：



```
#!/bin/bash
echo "\$*=" $*
echo "\"\$*\"=" "$*"
echo "\$@=" $@
echo "\"\$@\"=" "$@"
echo "print each param from \$*"
for var in $*
do
echo "$var"
done
echo "print each param from \$@"
for var in $@
do
echo "$var"
done
echo "print each param from \"\$*\""
for var in "$*"
do
echo "$var"
done
echo "print each param from \"\$@\""
for var in "$@"
do
echo "$var"
done
```



执行 ./test.sh "a" "b" "c" "d"，看到下面的结果：

```
$*=  a b c d
"$*"= a b c d
$@=  a b c d
"$@"= a b c d
print each param from $*
a
b
c
d
print each param from $@
a
b
c
d
print each param from "$*"
a b c d
print each param from "$@"
a
b
c
d
```



## 退出状态

$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。

退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。

不过，也有一些命令返回其他值，表示不同类型的错误。

下面例子中，命令成功执行：



```
$ sh test01.sh double moons
File Name: test01.sh
First Parameter : double
First Parameter : moons
Quoted Values: double moons
Quoted Values: double moons
Total Number of Parameters : 2

$ echo $？
0
```

# Linux的trap命令

我们在写`Shell`脚本的时候，执行某些自动化操作的时候，其实是很担心有人认为的通过键盘输入一些中断进程的指令的，我之前一直不知道该怎么处理这种情况，但是今天通过看别人脚本，偶然的机会看见了`trap`命令。

真是久旱逢甘霖~~哈，其实也没啥用，还是要在操作手册上大写几个字，执行脚本时，请不要执行自杀性操作。

## 1. Linux信号

Linux系统利用信号与系统中的进程进行通信。Linux的常见信号有：

| 信号 | 值      | 描述                           |
| ---- | ------- | ------------------------------ |
| 1    | SIGHP   | 挂起进程                       |
| 2    | SIGINT  | 终止进程                       |
| 3    | SIGQUIT | 停止进程                       |
| 9    | SIGKILL | 无条件终止进程                 |
| 15   | SIGTERM | 尽可能终止进程                 |
| 17   | SIGSTOP | 无条件停止进程，但不是终止进程 |
| 18   | SIGTSTP | 停止或暂停进程，但不终止进程   |
| 19   | SIGCONT | 继续运行停止的进程             |

## 2. 信号组合键

Ctrl+C组合键会产生SIGINT信号，Ctrl+Z会产生SIGTSTP信号。

## 3. trap命令

trap命令允许你来指定shell脚本要监视并拦截的Linux信号。trap命令的格式为：`trap commands signals`。

### demo1

shell脚本：

```
#!/bin/bash
# test trap command
trap "echo 'Sorry! I have trapped Ctrl-C'" SIGINT

echo This is a test script

count=1
while [ $count -le 10 ]
do
  echo "Loop $count"
  sleep 1
  count=$[ $count + 1 ]
done

echo The end.
```

运行结果：

```
This is a test script
Loop 1
Loop 2
^CSorry! I have trapped Ctrl-C
Loop 3
Loop 4
^CSorry! I have trapped Ctrl-C
Loop 5
Loop 6
Loop 7
Loop 8
^CSorry! I have trapped Ctrl-C
Loop 9
Loop 10
The end.
```

### demo2

除了在shell脚本中捕获信号外，也可以在shell退出时捕获，在trap命令后加上EXIT信号就行。

shell脚本：

```
#!/bin/bash
# test trap command
trap "echo Goodbye." EXIT

echo This is a test script

count=1
while [ $count -le 10 ]
do
  echo "Loop $count"
  sleep 1
  count=$[ $count + 1 ]
done

echo The end.
```

运行结果：

```
This is a test script
Loop 1
Loop 2
Loop 3
Loop 4
Loop 5
Loop 6
Loop 7
Loop 8
Loop 9
Loop 10
The end.
Goodbye.
```

### demo3——修改trap操作

```
#!/bin/bash
# test trap command

trap "echo 'Sorry! I have trapped Ctrl-C'" SIGINT

count=1
while [ $count -le 5 ]
do
  echo "Loop $count"
  sleep 1
  count=$[ $count + 1 ]
done


trap "echo 'Sorry! The trap has been modified.'" SIGINT

count=1
while [ $count -le 5 ]
do
  echo "Loop $count"
  sleep 1
  count=$[ $count + 1 ]
done

echo The end.
```

运行结果：

```
Loop 1
Loop 2
Loop 3
^CSorry! I have trapped Ctrl-C
Loop 4
Loop 5
Loop 1
Loop 2
Loop 3
^CSorry! The trap has been modified.
Loop 4
Loop 5
The end.
```

### demo4

删除捕获，命令形式为：`trap -- ***`，例如`trap -- SIGINT`

参考资料

1. Linux命令行与shell脚本大全

